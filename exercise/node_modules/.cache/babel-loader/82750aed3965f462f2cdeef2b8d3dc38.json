{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\Eric Romero\\\\Documents\\\\GitHub\\\\rehab-x\\\\exercise\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _objectSpread from \"C:\\\\Users\\\\Eric Romero\\\\Documents\\\\GitHub\\\\rehab-x\\\\exercise\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _slicedToArray from \"C:\\\\Users\\\\Eric Romero\\\\Documents\\\\GitHub\\\\rehab-x\\\\exercise\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\Eric Romero\\\\Documents\\\\GitHub\\\\rehab-x\\\\exercise\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport { useEffect, useState } from 'react';\nimport * as posenet from '@tensorflow-models/posenet';\nimport similarity from 'compute-cosine-similarity';\nimport l2norm from 'compute-l2norm';\nimport VPTreeFactory from 'vptree';\nimport { sortBy, chain } from 'lodash';\nimport { drawKeypoints, drawSkeleton } from './demo_util';\nimport { imagePaths, imageCategories } from '../dataset';\nexport var mediaSize = 500;\nvar imageScaleFactor = 0.5;\nvar outputStride = 32;\nvar flipHorizontal = false;\nvar minPartConfidence = 0.1;\nvar minConsecutivePoses = 10;\nexport function loadPoseData() {\n  return _loadPoseData.apply(this, arguments);\n}\n\nfunction _loadPoseData() {\n  _loadPoseData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var net, poseData, vptree;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return posenet.load();\n\n          case 2:\n            net = _context2.sent;\n            _context2.next = 5;\n            return buildPoseData(net, imagePaths);\n\n          case 5:\n            poseData = _context2.sent;\n            _context2.next = 8;\n            return buildVPTree(poseData);\n\n          case 8:\n            vptree = _context2.sent;\n            return _context2.abrupt(\"return\", {\n              net: net,\n              vptree: vptree\n            });\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _loadPoseData.apply(this, arguments);\n}\n\nexport function usePoseDetection(start, net, video, canvas) {\n  var _useState = useState(null),\n      _useState2 = _slicedToArray(_useState, 2),\n      pose = _useState2[0],\n      setPose = _useState2[1];\n\n  useEffect(function () {\n    if (video) {\n      var ctx = canvas.getContext('2d');\n      detectPoseInRealTime(net, video, function (pose) {\n        setPose(pose);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        var keypoints = pose.keypoints;\n        drawKeypoints(keypoints, minPartConfidence, ctx);\n        drawSkeleton(keypoints, minPartConfidence, ctx);\n      });\n    }\n  }, [video]);\n  return pose;\n}\nexport function useRepsCounter(pose, vptree) {\n  var _useState3 = useState([]),\n      _useState4 = _slicedToArray(_useState3, 1),\n      counter = _useState4[0];\n\n  if (pose) {\n    var match = findMostSimilarMatch(vptree, pose);\n    incrementPoseCount(counter, match.category);\n    var reps = countTotalReps(counter, 2);\n    return reps;\n  }\n\n  return 0;\n}\n\nfunction cosineDistanceMatching(poseVector1, poseVector2) {\n  var cosineSimilarity = similarity(poseVector1, poseVector2);\n  var distance = 2 * (1 - cosineSimilarity);\n  return Math.sqrt(distance);\n} // poseVector1 and poseVector2 are 52-float vectors composed of:\n// Values 0-33: are x,y coordinates for 17 body parts in alphabetical order\n// Values 34-51: are confidence values for each of the 17 body parts in alphabetical order\n// Value 51: A sum of all the confidence values\n// Again the lower the number, the closer the distance\n\n\nfunction weightedDistanceMatching(poseVector1, poseVector2) {\n  var partsEnd = parts.length * 2;\n  var scoresEnd = partsEnd + parts.length;\n  var vector1PoseXY = poseVector1.slice(0, partsEnd);\n  var vector1Confidences = poseVector1.slice(partsEnd, scoresEnd);\n  var vector1ConfidenceSum = poseVector1.slice(scoresEnd, scoresEnd + 1);\n  var vector2PoseXY = poseVector2.slice(0, partsEnd); // First summation\n\n  var summation1 = 1 / vector1ConfidenceSum; // Second summation\n\n  var summation2 = 0;\n\n  for (var i = 0; i < vector1PoseXY.length; i++) {\n    var tempConf = Math.floor(i / 2);\n    var tempSum = vector1Confidences[tempConf] * Math.abs(vector1PoseXY[i] - vector2PoseXY[i]);\n    summation2 = summation2 + tempSum;\n  }\n\n  return summation1 * summation2;\n}\n\nfunction buildVPTree(_x) {\n  return _buildVPTree.apply(this, arguments);\n}\n\nfunction _buildVPTree() {\n  _buildVPTree = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(poseData) {\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            return _context3.abrupt(\"return\", new Promise(function (resolve) {\n              resolve(VPTreeFactory.build(poseData, weightedDistanceMatching));\n            }));\n\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _buildVPTree.apply(this, arguments);\n}\n\nfunction findMostSimilarMatch(vptree, userPose) {\n  var pose = convertPoseToVector(userPose); // search the vp tree for the image pose that is nearest (in cosine distance) to userPose\n\n  var nearestImage = vptree.search(pose); // return index (in relation to poseData) of nearest match.\n\n  return {\n    index: nearestImage[0].i,\n    score: nearestImage[0].d,\n    category: imageCategories[nearestImage[0].i]\n  };\n}\n\nfunction buildPoseData(_x2, _x3) {\n  return _buildPoseData.apply(this, arguments);\n}\n\nfunction _buildPoseData() {\n  _buildPoseData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(net, paths) {\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return Promise.all(paths.map( /*#__PURE__*/function () {\n              var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(path) {\n                var imagePose;\n                return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                  while (1) {\n                    switch (_context4.prev = _context4.next) {\n                      case 0:\n                        _context4.next = 2;\n                        return estimatePoseOnImage(net, path);\n\n                      case 2:\n                        imagePose = _context4.sent;\n                        return _context4.abrupt(\"return\", convertPoseToVector(imagePose));\n\n                      case 4:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }\n                }, _callee4);\n              }));\n\n              return function (_x7) {\n                return _ref.apply(this, arguments);\n              };\n            }()));\n\n          case 2:\n            return _context5.abrupt(\"return\", _context5.sent);\n\n          case 3:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _buildPoseData.apply(this, arguments);\n}\n\nfunction loadImage(_x4) {\n  return _loadImage.apply(this, arguments);\n}\n\nfunction _loadImage() {\n  _loadImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(imagePath) {\n    var image, promise;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            image = new Image();\n            promise = new Promise(function (resolve, reject) {\n              image.crossOrigin = '';\n\n              image.onload = function () {\n                resolve(image);\n              };\n            });\n            image.src = imagePath;\n            return _context6.abrupt(\"return\", promise);\n\n          case 4:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _loadImage.apply(this, arguments);\n}\n\nvar parts = ['nose', // 'leftEye',\n// 'rightEye',\n// 'leftEar',\n// 'rightEar',\n'leftShoulder', 'rightShoulder', 'leftElbow', 'rightElbow', 'leftWrist', 'rightWrist', 'leftHip', 'rightHip', 'leftKnee', 'rightKnee', 'leftAnkle', 'rightAnkle'];\n\nfunction convertPoseToVector(pose) {\n  var keypoints = sortBy(normalizeKeypoints(pose), 'part');\n  var vector = keypoints.reduce(function (acc, keypoint) {\n    if (parts.includes(keypoint.part)) {\n      acc.push(keypoint.normalizedPosition.x);\n      acc.push(keypoint.normalizedPosition.y);\n    }\n\n    return acc;\n  }, []);\n  var scoreSum = keypoints.reduce(function (acc, keypoint) {\n    vector.push(keypoint.score);\n    return acc + keypoint.score;\n  }, 0);\n  vector.push(scoreSum);\n  return l2normPoseVector(vector);\n}\n\nfunction normalizeKeypoints(pose) {\n  var boundingBox = posenet.getBoundingBox(pose.keypoints);\n  var normalizedPoints = pose.keypoints.map(function (keypoint) {\n    return _objectSpread({}, keypoint, {\n      normalizedPosition: {\n        x: keypoint.position.x - boundingBox.minX,\n        y: keypoint.position.y - boundingBox.minY\n      }\n    });\n  });\n  return normalizedPoints;\n}\n\nfunction l2normPoseVector(vector) {\n  var norm = l2norm(vector);\n  var normalized = vector.map(function (value) {\n    return value / norm * (value / norm);\n  }); // console.log(normalized.reduce((acc, value) => acc + value, 0))\n\n  return normalized;\n}\n\nfunction estimatePoseOnImage(_x5, _x6) {\n  return _estimatePoseOnImage.apply(this, arguments);\n}\n\nfunction _estimatePoseOnImage() {\n  _estimatePoseOnImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(net, imagePath) {\n    var imageElement, pose;\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.next = 2;\n            return loadImage(imagePath);\n\n          case 2:\n            imageElement = _context7.sent;\n            imageElement.width = mediaSize;\n            imageElement.height = mediaSize;\n            _context7.next = 7;\n            return net.estimateSinglePose(imageElement, imageScaleFactor, flipHorizontal, outputStride);\n\n          case 7:\n            pose = _context7.sent;\n            console.log(pose);\n            return _context7.abrupt(\"return\", pose);\n\n          case 10:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _estimatePoseOnImage.apply(this, arguments);\n}\n\nfunction detectPoseInRealTime(net, video, onPose) {\n  // video.playbackRate = 0.3;\n  function poseDetectionFrame() {\n    return _poseDetectionFrame.apply(this, arguments);\n  }\n\n  function _poseDetectionFrame() {\n    _poseDetectionFrame = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var pose;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return net.estimateSinglePose(video, imageScaleFactor, flipHorizontal, outputStride);\n\n            case 2:\n              pose = _context.sent;\n              onPose(pose);\n\n              if (!video.paused) {\n                requestAnimationFrame(poseDetectionFrame);\n              }\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    return _poseDetectionFrame.apply(this, arguments);\n  }\n\n  poseDetectionFrame();\n}\n\nfunction incrementPoseCount(counter, category) {\n  if (counter.length === 0) {\n    counter.push([category, 1]);\n  } else if (counter[counter.length - 1][0] === category) {\n    counter[counter.length - 1][1]++;\n  } else {\n    counter.push([category, 1]);\n  }\n}\n\nfunction countTotalReps(counter, numCategories) {\n  var reps = chain(counter).filter(function (p) {\n    return p[1] >= minConsecutivePoses;\n  }).reduce(function (acc, pose) {\n    if (acc.length === 0) {\n      acc.push(pose);\n    } else {\n      var previousPose = acc[acc.length - 1];\n\n      if (previousPose[0] === pose[0]) {\n        previousPose[1] += pose[1];\n      } else {\n        acc.push(pose);\n      }\n    }\n\n    return acc;\n  }, []).value();\n  return Math.max(0, Math.floor((reps.length - 1) / numCategories));\n}","map":{"version":3,"sources":["C:/Users/Eric Romero/Documents/GitHub/rehab-x/exercise/src/components/poseUtils.js"],"names":["useEffect","useState","posenet","similarity","l2norm","VPTreeFactory","sortBy","chain","drawKeypoints","drawSkeleton","imagePaths","imageCategories","mediaSize","imageScaleFactor","outputStride","flipHorizontal","minPartConfidence","minConsecutivePoses","loadPoseData","load","net","buildPoseData","poseData","buildVPTree","vptree","usePoseDetection","start","video","canvas","pose","setPose","ctx","getContext","detectPoseInRealTime","clearRect","width","height","keypoints","useRepsCounter","counter","match","findMostSimilarMatch","incrementPoseCount","category","reps","countTotalReps","cosineDistanceMatching","poseVector1","poseVector2","cosineSimilarity","distance","Math","sqrt","weightedDistanceMatching","partsEnd","parts","length","scoresEnd","vector1PoseXY","slice","vector1Confidences","vector1ConfidenceSum","vector2PoseXY","summation1","summation2","i","tempConf","floor","tempSum","abs","Promise","resolve","build","userPose","convertPoseToVector","nearestImage","search","index","score","d","paths","all","map","path","estimatePoseOnImage","imagePose","loadImage","imagePath","image","Image","promise","reject","crossOrigin","onload","src","normalizeKeypoints","vector","reduce","acc","keypoint","includes","part","push","normalizedPosition","x","y","scoreSum","l2normPoseVector","boundingBox","getBoundingBox","normalizedPoints","position","minX","minY","norm","normalized","value","imageElement","estimateSinglePose","console","log","onPose","poseDetectionFrame","paused","requestAnimationFrame","numCategories","filter","p","previousPose","max"],"mappings":"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","sourcesContent":["import { useEffect, useState } from 'react';\r\nimport * as posenet from '@tensorflow-models/posenet';\r\nimport similarity from 'compute-cosine-similarity';\r\nimport l2norm from 'compute-l2norm';\r\nimport VPTreeFactory from 'vptree';\r\nimport { sortBy, chain } from 'lodash';\r\nimport { drawKeypoints, drawSkeleton } from './demo_util';\r\n\r\nimport { imagePaths, imageCategories } from '../dataset';\r\n\r\nexport const mediaSize = 500;\r\nconst imageScaleFactor = 0.5;\r\nconst outputStride = 32;\r\nconst flipHorizontal = false;\r\nconst minPartConfidence = 0.1;\r\nconst minConsecutivePoses = 10;\r\n\r\nexport async function loadPoseData() {\r\n  const net = await posenet.load();\r\n  const poseData = await buildPoseData(net, imagePaths);\r\n  const vptree = await buildVPTree(poseData);\r\n  return { net, vptree };\r\n}\r\n\r\nexport function usePoseDetection(start, net, video, canvas) {\r\n  const [pose, setPose] = useState(null);\r\n  useEffect(\r\n    () => {\r\n      if (video) {\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        detectPoseInRealTime(net, video, pose => {\r\n          setPose(pose);\r\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n          const { keypoints } = pose;\r\n          drawKeypoints(keypoints, minPartConfidence, ctx);\r\n          drawSkeleton(keypoints, minPartConfidence, ctx);\r\n        });\r\n      }\r\n    },\r\n    [video]\r\n  );\r\n  return pose;\r\n}\r\n\r\nexport function useRepsCounter(pose, vptree) {\r\n  const [counter] = useState([]);\r\n  if (pose) {\r\n    const match = findMostSimilarMatch(vptree, pose);\r\n    incrementPoseCount(counter, match.category);\r\n    const reps = countTotalReps(counter, 2);\r\n    return reps;\r\n  }\r\n  return 0;\r\n}\r\n\r\nfunction cosineDistanceMatching(poseVector1, poseVector2) {\r\n  let cosineSimilarity = similarity(poseVector1, poseVector2);\r\n  let distance = 2 * (1 - cosineSimilarity);\r\n  return Math.sqrt(distance);\r\n}\r\n\r\n// poseVector1 and poseVector2 are 52-float vectors composed of:\r\n// Values 0-33: are x,y coordinates for 17 body parts in alphabetical order\r\n// Values 34-51: are confidence values for each of the 17 body parts in alphabetical order\r\n// Value 51: A sum of all the confidence values\r\n// Again the lower the number, the closer the distance\r\nfunction weightedDistanceMatching(poseVector1, poseVector2) {\r\n  const partsEnd = parts.length * 2;\r\n  const scoresEnd = partsEnd + parts.length;\r\n  let vector1PoseXY = poseVector1.slice(0, partsEnd);\r\n  let vector1Confidences = poseVector1.slice(partsEnd, scoresEnd);\r\n  let vector1ConfidenceSum = poseVector1.slice(scoresEnd, scoresEnd + 1);\r\n\r\n  let vector2PoseXY = poseVector2.slice(0, partsEnd);\r\n\r\n  // First summation\r\n  let summation1 = 1 / vector1ConfidenceSum;\r\n\r\n  // Second summation\r\n  let summation2 = 0;\r\n  for (let i = 0; i < vector1PoseXY.length; i++) {\r\n    let tempConf = Math.floor(i / 2);\r\n    let tempSum =\r\n      vector1Confidences[tempConf] *\r\n      Math.abs(vector1PoseXY[i] - vector2PoseXY[i]);\r\n    summation2 = summation2 + tempSum;\r\n  }\r\n\r\n  return summation1 * summation2;\r\n}\r\n\r\nasync function buildVPTree(poseData) {\r\n  // Initialize our vptree with our imagesâ€™ pose data and a distance function\r\n  return new Promise(resolve => {\r\n    resolve(VPTreeFactory.build(poseData, weightedDistanceMatching));\r\n  });\r\n}\r\n\r\nfunction findMostSimilarMatch(vptree, userPose) {\r\n  const pose = convertPoseToVector(userPose);\r\n  // search the vp tree for the image pose that is nearest (in cosine distance) to userPose\r\n  let nearestImage = vptree.search(pose);\r\n\r\n  // return index (in relation to poseData) of nearest match.\r\n  return {\r\n    index: nearestImage[0].i,\r\n    score: nearestImage[0].d,\r\n    category: imageCategories[nearestImage[0].i],\r\n  };\r\n}\r\n\r\nasync function buildPoseData(net, paths) {\r\n  return await Promise.all(\r\n    paths.map(async path => {\r\n      const imagePose = await estimatePoseOnImage(net, path);\r\n      return convertPoseToVector(imagePose);\r\n    })\r\n  );\r\n}\r\n\r\nasync function loadImage(imagePath) {\r\n  const image = new Image();\r\n  const promise = new Promise((resolve, reject) => {\r\n    image.crossOrigin = '';\r\n    image.onload = () => {\r\n      resolve(image);\r\n    };\r\n  });\r\n\r\n  image.src = imagePath;\r\n  return promise;\r\n}\r\n\r\nconst parts = [\r\n  'nose',\r\n  // 'leftEye',\r\n  // 'rightEye',\r\n  // 'leftEar',\r\n  // 'rightEar',\r\n\r\n  'leftShoulder',\r\n  'rightShoulder',\r\n\r\n  'leftElbow',\r\n  'rightElbow',\r\n  'leftWrist',\r\n  'rightWrist',\r\n\r\n  'leftHip',\r\n  'rightHip',\r\n  'leftKnee',\r\n  'rightKnee',\r\n  'leftAnkle',\r\n  'rightAnkle',\r\n];\r\nfunction convertPoseToVector(pose) {\r\n  const keypoints = sortBy(normalizeKeypoints(pose), 'part');\r\n  const vector = keypoints.reduce((acc, keypoint) => {\r\n    if (parts.includes(keypoint.part)) {\r\n      acc.push(keypoint.normalizedPosition.x);\r\n      acc.push(keypoint.normalizedPosition.y);\r\n    }\r\n    return acc;\r\n  }, []);\r\n\r\n  const scoreSum = keypoints.reduce((acc, keypoint) => {\r\n    vector.push(keypoint.score);\r\n    return acc + keypoint.score;\r\n  }, 0);\r\n\r\n  vector.push(scoreSum);\r\n  return l2normPoseVector(vector);\r\n}\r\n\r\nfunction normalizeKeypoints(pose) {\r\n  const boundingBox = posenet.getBoundingBox(pose.keypoints);\r\n\r\n  const normalizedPoints = pose.keypoints.map(keypoint => {\r\n    return {\r\n      ...keypoint,\r\n      normalizedPosition: {\r\n        x: keypoint.position.x - boundingBox.minX,\r\n        y: keypoint.position.y - boundingBox.minY,\r\n      },\r\n    };\r\n  });\r\n  return normalizedPoints;\r\n}\r\n\r\nfunction l2normPoseVector(vector) {\r\n  const norm = l2norm(vector);\r\n  const normalized = vector.map(value => (value / norm) * (value / norm));\r\n  // console.log(normalized.reduce((acc, value) => acc + value, 0))\r\n  return normalized;\r\n}\r\n\r\nasync function estimatePoseOnImage(net, imagePath) {\r\n  // load the posenet model from a checkpoint\r\n  const imageElement = await loadImage(imagePath);\r\n  imageElement.width = mediaSize;\r\n  imageElement.height = mediaSize;\r\n\r\n  const pose = await net.estimateSinglePose(\r\n    imageElement,\r\n    imageScaleFactor,\r\n    flipHorizontal,\r\n    outputStride\r\n  );\r\n\r\n  console.log(pose);\r\n  return pose;\r\n}\r\n\r\nfunction detectPoseInRealTime(net, video, onPose) {\r\n  // video.playbackRate = 0.3;\r\n\r\n  async function poseDetectionFrame() {\r\n    const pose = await net.estimateSinglePose(\r\n      video,\r\n      imageScaleFactor,\r\n      flipHorizontal,\r\n      outputStride\r\n    );\r\n\r\n    onPose(pose);\r\n\r\n    if (!video.paused) {\r\n      requestAnimationFrame(poseDetectionFrame);\r\n    }\r\n  }\r\n\r\n  poseDetectionFrame();\r\n}\r\n\r\nfunction incrementPoseCount(counter, category) {\r\n  if (counter.length === 0) {\r\n    counter.push([category, 1]);\r\n  } else if (counter[counter.length - 1][0] === category) {\r\n    counter[counter.length - 1][1]++;\r\n  } else {\r\n    counter.push([category, 1]);\r\n  }\r\n}\r\n\r\nfunction countTotalReps(counter, numCategories) {\r\n  const reps = chain(counter)\r\n    .filter(p => p[1] >= minConsecutivePoses)\r\n    .reduce((acc, pose) => {\r\n      if (acc.length === 0) {\r\n        acc.push(pose);\r\n      } else {\r\n        const previousPose = acc[acc.length - 1];\r\n        if (previousPose[0] === pose[0]) {\r\n          previousPose[1] += pose[1];\r\n        } else {\r\n          acc.push(pose);\r\n        }\r\n      }\r\n      return acc;\r\n    }, [])\r\n    .value();\r\n\r\n  return Math.max(0, Math.floor((reps.length - 1) / numCategories));\r\n}\r\n"]},"metadata":{},"sourceType":"module"}